<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div style="text-align: center">
      <canvas id="canvas" height="404" width="500"> </canvas>
    </div>
  </body>

  <script>
    /*My finding when creating this :
1. everything is inside the canvas, you can't have a small canvas and draw beyond what you defined

challenge remains:
1. Online there is a "DOMloaded" listener i didn't get that to work, i asssume it loaded everything by default
//when loaded, this will happen anyway
*/

    // create the coordinate array
    const cvs = document.getElementById('canvas');
    const ctx = cvs.getContext('2d');

    // 12 wide and 20 height
    const arrayWidth = 12;
    const arrayHeight = 20;
    // each block takes 20 pixel
    const scale = 20;

    // Initialising game data
    let score = 0;
    let level = 1;
    let lineClear = 0;
    // initially it starts at 3 second
    let initialDropTime = 2000;

    // define the actual coordinate in pixel
    let coorArray = Array(arrayHeight)
      .fill(0)
      .map((row) => Array(arrayWidth).fill(0));
    let gameBoardArray = Array(arrayHeight)
      .fill(0)
      .map((row) => Array(arrayWidth).fill(0));

    // create a array that store all the colour that a square should be
    let stopedShapeArray = Array(arrayHeight)
      .fill(0)
      .map((row) => Array(arrayWidth).fill(0));
    let gameBoardColorArray = Array(arrayHeight)
      .fill(0)
      .map((row) => Array(arrayWidth).fill('#3e3e3e'));

    // automatically drop every after every interval
    let DropEvent = window.setInterval(() => {
      curTetromino.update('Down');
    }, initialDropTime / level);

    // draw the info block
    ctx.fillStyle = '#3e3e3e';
    ctx.fillRect(0, 0, 244, 404);

    ctx.font = '21px Arial';
    ctx.fillText('Author: Jac', 270, 400);

    ctx.font = '21px Arial';
    ctx.fillText('SCORE', 270, 20);
    ctx.strokeRect(270, 29, 200, 24);
    ctx.fillText(score.toString(), 280, 49);

    ctx.font = '21px Arial';
    ctx.fillText('LINE CLEAR', 270, 79);
    ctx.strokeRect(270, 88, 200, 24);
    ctx.fillText(lineClear.toString(), 280, 108);

    ctx.fillText('LEVEL', 270, 136);
    ctx.strokeRect(270, 145, 200, 24);
    ctx.fillText(level.toString(), 280, 165);

    ctx.fillText('CONTROLS', 270, 196);
    ctx.strokeRect(270, 205, 200, 148);

    ctx.fillText('UP : Rotate Right', 280, 225);
    ctx.fillText('V  : Rotate Left', 280, 249);
    ctx.fillText('Down : Move Down ', 280, 273);
    ctx.fillText('Left : Move Left ', 280, 297);
    ctx.fillText('Right : Move Right', 280, 321);
    ctx.fillText('Space : Hard Drop ', 280, 345);

    class Tetromino {
      constructor(tetro, color) {
        this.tetroArray = tetro;
        //every time start at the fith column of the game board
        //where tetromino starts falling, cloumne as Y , row as X
        this.startX = 5;
        this.startY = 0;
        this.color = color;
      }

      // this function will draw the tetromino and record it.
      drawTetromino(y = this.startY, x = this.startX) {
        // console.log(gameBoardArray);
        for (let i = 0; i < this.tetroArray.length; i++) {
          ctx.fillStyle = this.color;
          // 16 16 because leaving 4 pixel for edges
          ctx.fillRect(
            coorArray[this.tetroArray[i][0] + y][this.tetroArray[i][1] + x].x,
            coorArray[this.tetroArray[i][0] + y][this.tetroArray[i][1] + x].y,
            16,
            16
          );
          gameBoardArray[this.tetroArray[i][0] + y][
            this.tetroArray[i][1] + x
          ] = 1;
          gameBoardColorArray[this.tetroArray[i][0] + y][
            this.tetroArray[i][1] + x
          ] = this.color;
        }
      }
      // this function will delete the tetromino on the board.
      deleteTetromino() {
        for (let i = 0; i < this.tetroArray.length; i++) {
          ctx.fillStyle = '#3e3e3e';
          ctx.fillRect(
            coorArray[this.tetroArray[i][0] + this.startY][
              this.tetroArray[i][1] + this.startX
            ].x,
            coorArray[this.tetroArray[i][0] + this.startY][
              this.tetroArray[i][1] + this.startX
            ].y,
            16,
            16
          );
          gameBoardArray[this.tetroArray[i][0] + this.startY][
            this.tetroArray[i][1] + this.startX
          ] = 0;
          gameBoardColorArray[this.tetroArray[i][0] + this.startY][
            this.tetroArray[i][1] + this.startX
          ] = '#3e3e3e';
        }
      }

      // this function will update any changes
      update(direction) {
        this.deleteTetromino();
        if (
          direction == 'Left' &&
          !this.hittingWall(direction) &&
          !this.horizontalCollsion(direction)
        ) {
          this.startX--;
        } else if (
          direction == 'Right' &&
          !this.hittingWall(direction) &&
          !this.horizontalCollsion(direction)
        ) {
          this.startX++;
        } else if (direction == 'Down' && this.VerticalCollision()) {
          console.log('this tetromino now locked in place');
        } else if (direction == 'Down') {
          this.startY++;
        } else if (direction == ' ') {
          console.log('Hard Drop!');
          this.hardDrop();
        } else if (direction == 'Up') {
          this.rotateRight();
        } else if (direction == 'v') {
          this.rotateLeft();
        }
        this.drawTetromino();
      }

      // redraw the new tetromino.
      restart() {
        this.drawTetromino();
        //store this into a shtopedShapeArray for checking for horizontal collision
        stopedShapeArray = gameBoardArray;
        console.log('recreate tetro now!');
        //recreate an other tetromino
        [this.tetroArray, this.color] = createTetromino();
        this.startX = 5;
        this.startY = 0;
        this.shape = '';
        //everytime we restart check if we lose
        if (this.checkLose()) {
          console.log('you lost');
          alert(
            `You lost! Your score is ${score}! You have reached level ${level},line clear was: ${lineClear}. Click 'Ok' to replay`
          );
          window.clearInterval(DropEvent);
          window.location.reload(true);
        }
      }

      // check for vertical collision
      VerticalCollision() {
        for (let i = 0; i < this.tetroArray.length; i++) {
          //must detected if it is 20 first, otherwise it will crash the program
          if (this.tetroArray[i][0] + this.startY + 1 == arrayHeight) {
            console.log('Hitting the bottom');
            this.restart();
            this.checkClearRow();
            this.drawTetromino();
            return true;
          } else if (
            stopedShapeArray[this.tetroArray[i][0] + this.startY + 1][
              this.tetroArray[i][1] + this.startX
            ] == 1
          ) {
            console.log('there is vertical collision');
            this.restart();
            this.checkClearRow();
            this.drawTetromino();
            return true;
          }
        }
        return false;
      }

      // hard dropping!!
      hardDrop() {
        while (!this.VerticalCollision()) {
          this.startY++;
        }
      }

      // detect for horizontal boundary
      hittingWall(direction) {
        for (let i = 0; i < this.tetroArray.length; i++) {
          if (this.tetroArray[i][1] + this.startX == 0 && direction == 'Left') {
            console.log('Hitting the left wall');
            return true;
          } else if (
            this.tetroArray[i][1] + this.startX + 1 == arrayWidth &&
            direction == 'Right'
          ) {
            console.log('Hitting the right wall');
            return true;
          }
        }
        return false;
      }

      // check for collision
      horizontalCollsion(direction) {
        for (let i = 0; i < this.tetroArray.length; i++) {
          if (
            stopedShapeArray[this.tetroArray[i][0] + this.startY][
              this.tetroArray[i][1] + this.startX - 1
            ] == 1 &&
            direction == 'Left'
          ) {
            console.log('Hitting the left stop chuck');
            return true;
          } else if (
            stopedShapeArray[this.tetroArray[i][0] + this.startY][
              this.tetroArray[i][1] + this.startX + 1
            ] == 1 &&
            direction == 'Right'
          ) {
            console.log('Hitting the right stop chuck');
            return true;
          }
        }
        return false;
      }

      // Rotate right, hard coded it
      rotateRight() {
        let rotateArray = [];
        if (this.tetroArray == Oshape || this.shape == 'O') {
          this.shape = 'O';
          rotateArray = Oshape;
        } else if (this.tetroArray == Ishape || this.shape == 'I') {
          rotateArray = [
            [0, 2],
            [1, 2],
            [2, 2],
            [3, 2],
          ];
          this.shape = 'rI';
        } else if (this.shape == 'lI' || this.shape == 'rI') {
          rotateArray = Ishape;
          this.shape = 'I';
        } else if (this.tetroArray == Sshape || this.shape == 'S') {
          rotateArray = [
            [0, 1],
            [1, 1],
            [1, 2],
            [2, 2],
          ];
          this.shape = 'rS';
        } else if (this.shape == 'rS') {
          rotateArray = Sshape;
          this.shape = 'S';
        } else if (this.tetroArray == Zshape || this.shape == 'Z') {
          rotateArray = [
            [0, 2],
            [1, 1],
            [1, 2],
            [2, 1],
          ];
          this.shape = 'rZ';
        } else if (this.shape == 'rZ') {
          rotateArray = Zshape;
          this.shape = 'Z';
        } else if (!this.shape) {
          rotateArray.push([1, 1]);
          for (let i = 0; i < this.tetroArray.length; i++) {
            if (this.tetroArray[i][0] == 0 && this.tetroArray[i][1] == 0) {
              rotateArray.push([0, 2]);
            } else if (
              this.tetroArray[i][0] == 0 &&
              this.tetroArray[i][1] == 1
            ) {
              rotateArray.push([1, 2]);
            } else if (
              this.tetroArray[i][0] == 0 &&
              this.tetroArray[i][1] == 2
            ) {
              rotateArray.push([2, 2]);
            } else if (
              this.tetroArray[i][0] == 1 &&
              this.tetroArray[i][1] == 0
            ) {
              rotateArray.push([0, 1]);
            } else if (
              this.tetroArray[i][0] == 1 &&
              this.tetroArray[i][1] == 2
            ) {
              rotateArray.push([2, 1]);
            } else if (
              this.tetroArray[i][0] == 2 &&
              this.tetroArray[i][1] == 0
            ) {
              rotateArray.push([0, 0]);
            } else if (
              this.tetroArray[i][0] == 2 &&
              this.tetroArray[i][1] == 1
            ) {
              rotateArray.push([1, 0]);
            } else if (
              this.tetroArray[i][0] == 2 &&
              this.tetroArray[i][1] == 2
            ) {
              rotateArray.push([2, 0]);
            }
          }
        }
        // check if it can be rotated
        if (this.rotatable(rotateArray)) {
          this.tetroArray = rotateArray;
        }
      }
      // Rotate left, hard coded it
      rotateLeft() {
        let rotateArray = [];
        if (this.tetroArray == Oshape || this.shape == 'O') {
          this.shape = 'O';
          rotateArray = Oshape;
        } else if (this.tetroArray == Ishape || this.shape == 'I') {
          rotateArray = [
            [0, 1],
            [1, 1],
            [2, 1],
            [3, 1],
          ];
          this.shape = 'lI';
        } else if (this.shape == 'lI' || this.shape == 'rI') {
          rotateArray = Ishape;
          this.shape = 'I';
          // can't be bother to change S and Z
        } else if (this.tetroArray == Sshape || this.shape == 'S') {
          rotateArray = [
            [0, 1],
            [1, 1],
            [1, 2],
            [2, 2],
          ];
          this.shape = 'rS';
        } else if (this.shape == 'rS') {
          rotateArray = Sshape;
          this.shape = 'S';
        } else if (this.tetroArray == Zshape || this.shape == 'Z') {
          rotateArray = [
            [0, 2],
            [1, 1],
            [1, 2],
            [2, 1],
          ];
          this.shape = 'rZ';
        } else if (this.shape == 'rZ') {
          rotateArray = Zshape;
          this.shape = 'Z';
        } else if (!this.shape) {
          rotateArray.push([1, 1]);
          for (let i = 0; i < this.tetroArray.length; i++) {
            if (this.tetroArray[i][0] == 0 && this.tetroArray[i][1] == 0) {
              rotateArray.push([2, 0]);
            } else if (
              this.tetroArray[i][0] == 0 &&
              this.tetroArray[i][1] == 1
            ) {
              rotateArray.push([1, 0]);
            } else if (
              this.tetroArray[i][0] == 0 &&
              this.tetroArray[i][1] == 2
            ) {
              rotateArray.push([0, 0]);
            } else if (
              this.tetroArray[i][0] == 1 &&
              this.tetroArray[i][1] == 0
            ) {
              rotateArray.push([2, 1]);
            } else if (
              this.tetroArray[i][0] == 1 &&
              this.tetroArray[i][1] == 2
            ) {
              rotateArray.push([0, 1]);
            } else if (
              this.tetroArray[i][0] == 2 &&
              this.tetroArray[i][1] == 0
            ) {
              rotateArray.push([2, 2]);
            } else if (
              this.tetroArray[i][0] == 2 &&
              this.tetroArray[i][1] == 1
            ) {
              rotateArray.push([1, 2]);
            } else if (
              this.tetroArray[i][0] == 2 &&
              this.tetroArray[i][1] == 2
            ) {
              rotateArray.push([0, 2]);
            }
          }
        }
        // check if it can be rotated
        if (this.rotatable(rotateArray)) {
          this.tetroArray = rotateArray;
        }
      }

      // check for to see if it's rotatable
      rotatable(rotateArray) {
        for (let i = 0; i < rotateArray.length; i++) {
          if (
            rotateArray[i][0] + this.startY >= arrayHeight ||
            rotateArray[i][1] + this.startX >= arrayWidth ||
            rotateArray[i][1] + this.startX < 0
          ) {
            console.log('Rotation hit the boundary');
            return false;
          } else if (
            stopedShapeArray[rotateArray[i][0] + this.startY][
              rotateArray[i][1] + this.startX
            ] == 1
          ) {
            console.log('Rotation will hit the block');
            return false;
          }
        }
        return true;
      }

      // check to see if a row can be cleared
      checkClearRow() {
        let combo = -1;
        for (let i = 0; i < stopedShapeArray.length; i++) {
          if (stopedShapeArray[i].indexOf(0) == -1) {
            console.log('clearing row');
            lineClear++;
            combo++;
            this.levelUp();
            // print the lineClear after each clear
            ctx.font = '21px Arial';
            ctx.fillStyle = 'white';
            ctx.fillRect(270, 88, 200, 24);
            ctx.fillStyle = '#3e3e3e';
            ctx.strokeStyle = '#3e3e3e';
            ctx.strokeRect(270, 88, 200, 24);
            ctx.fillText(lineClear.toString(), 280, 108);

            for (let j = i; j > 0; j--) {
              stopedShapeArray[j] = stopedShapeArray[j - 1];
              gameBoardColorArray[j] = gameBoardColorArray[j - 1];
            }
            stopedShapeArray[0] = Array(arrayWidth).fill(0);
            gameBoardColorArray[0] = Array(arrayWidth).fill('#3e3e3e');
            console.log('finish clearing row');
            //console.log("here are all the y")
            for (let i = 0; i < coorArray.length; i++) {
              for (let j = 0; j < coorArray[i].length; j++) {
                ctx.fillStyle = gameBoardColorArray[i][j];
                ctx.fillRect(coorArray[i][j].x, coorArray[i][j].y, 16, 16);
              }
            }
            // account for combo score, and iterate it
            console.log(combo);
            console.log(score);
            score += 10 * combo + level * 5;
            console.log(score);
            ctx.font = '21px Arial';
            ctx.fillStyle = 'white';
            ctx.fillRect(270, 29, 200, 24);
            ctx.fillStyle = '#3e3e3e';
            ctx.strokeStyle = '#3e3e3e';
            ctx.strokeRect(270, 29, 200, 24);
            ctx.fillText(score.toString(), 280, 49);
          }
        }
      }

      // check to see if we can level up, it is set to be every 5 lines we can level up
      levelUp() {
        if (lineClear % 4 == 0 && lineClear != 0) {
          level++;
          window.clearInterval(DropEvent);
          DropEvent = window.setInterval(() => {
            curTetromino.update('Down');
            // set interval can drop faster over time
          }, initialDropTime / level);
          ctx.font = '21px Arial';
          ctx.fillStyle = 'white';
          ctx.fillRect(270, 145, 200, 24);
          ctx.fillStyle = '#3e3e3e';
          ctx.strokeStyle = '#3e3e3e';
          ctx.strokeRect(270, 145, 200, 24);
          ctx.fillText(level.toString(), 280, 165);
        }
      }

      // check if we lost the game
      checkLose() {
        for (let i = 0; i < this.tetroArray.length; i++) {
          if (
            stopedShapeArray[this.tetroArray[i][0] + this.startY][
              this.tetroArray[i][1] + this.startX
            ] == 1
          ) {
            return true;
          }
        }
        return false;
      }
    }

    // initiallising the game here
    // The seven Tetromino shape with corresponding colour.
    let Tshape = [
      [1, 0],
      [0, 1],
      [1, 1],
      [1, 2],
    ];
    let Oshape = [
      [0, 0],
      [0, 1],
      [1, 0],
      [1, 1],
    ];
    let Lshape = [
      [1, 0],
      [1, 1],
      [1, 2],
      [0, 2],
    ];
    let Jshape = [
      [1, 0],
      [1, 1],
      [1, 2],
      [0, 0],
    ];
    let Zshape = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 2],
    ];
    let Sshape = [
      [0, 1],
      [1, 0],
      [1, 1],
      [0, 2],
    ];
    let Ishape = [
      [0, 1],
      [0, 0],
      [0, 2],
      [0, 3],
    ];
    let tetrominos = [Tshape, Oshape, Lshape, Jshape, Zshape, Ishape, Sshape];
    let tetrominoColors = [
      '#a8e6cf',
      '#dcedc1',
      '#ffd3b6',
      '#ffaaa5',
      '#ff8b94',
      '#ff9f43',
      '#00aedb',
    ];

    //this function create the coordinate array
    (createCoorArray = () => {
      for (let j = 0; j < arrayHeight; j++) {
        for (let i = 0; i < arrayWidth; i++) {
          coorArray[j][i] = { x: 4 + i * scale, y: 4 + j * scale };
          // ctx.fillRect(4+(i*scale),4+(j*scale),16,16)
        }
      }
    })();

    // create a random tetromino
    createTetromino = () => {
      // randomised which tetromino to put in
      let num = Math.floor(Math.random() * 7);
      return [tetrominos[num], tetrominoColors[num]];
    };

    // draw the first tetromino
    let curTetromino = new Tetromino(...createTetromino());
    curTetromino.drawTetromino();

    //listen for key press
    document.addEventListener('keydown', (evt) => {
      // console.log(evt);
      const direction = evt.key.replace('Arrow', '');
      curTetromino.update(direction);
    });
  </script>
</html>
